# Bloom's Taxonomy

--8<-- "includes/admonitions/admonish-taxonomy.md"

--8<-- "includes/abbreviations.md"

As you become a proactive programmer, it is important for you to know how the
projects on this site were designed in terms of the learning type that they
support and the complexity of the tasks they ask you to complete.[^1] While you
may be thinking that this is only a topic for teachers, it turns out that
knowing the basics of this taxonomy is also helpful for learners! For instance,
this site features assignments and learning objectives that are connected to
specific levels in this taxonomy.

Don't forget that these levels are organized from those that have the least
amount of cognitive complexity to those that have the most. Ready to see
examples of programming projects and how they connect to Bloom's taxonomy? Using
direct quotes from [Greg Wilson](https://third-bit.com/)'s book called [Teaching
Tech Together](https://teachtogether.tech/), let's describe the taxonomy's
levels and example programming tasks.[^2] It's worth noting that many of the
examples in this list will require the design and implementation of a program,
which is normally the domain of the **creating** level. Since the study of
proactive programming often requires the creation of source code, this task is
supported with instructor-provided programs at less difficult levels and done
by the learner when more cognitive challenge is appropriate.

- **Remembering**: "Exhibit memory of previously learned material by recalling
  facts, terms, basic concepts, and answers."

    * **Keywords**: recognize, list, describe, name, find.
    * **Example**: Run a program that performs a numerical calculation, find the
      iteration construct used in the program, observe its output when run in
      the terminal window, and use a text editor to describe both the output and
      why the program produces it.

- **Understanding**: "Demonstrate understanding of facts and ideas by organizing,
    comparing, translating, interpreting, giving descriptions, and stating main
    ideas."

    * **Keywords**: interpret, summarize, paraphrase, classify, explain.
    * **Example**: After running a program that performs the conversion of
      temperature values, organize it into separate functions with descriptive
      documentation and explain how the functions work together to produce the
      output observed when it is run.

- **Applying**: "Solve new problems by applying acquired knowledge, facts,
    techniques, and rules in a different way."

    * **Keywords**: build, identify, use, plan, select.
    * **Example**: Leveraging previously acquired knowledge about file input and
      parsing, select from existing functions to implement a program that
      iteratively searches a contact database for details about the individuals
      in someone's professional network.

- **Analyzing**: "Examine and break information into parts by identifying
    motives or causes; make inferences and find evidence to support
    generalizations."

    * **Keywords**: compare, contrast, simplify.
    * **Example**: After implementing a program that features multiple ways to
      sort a list input from a file, compare and contrast the efficiency and
      implementation effort associated with each approach, attempting to
      understand the trade-offs evident in each one.

- **Evaluating**: "Present and defend opinions by making judgments about
    information, validity of ideas, or quality of work based on a set of
    criteria."

    * **Keywords**: check, choose, critique, prove, rate.
    * **Example**: After defining the assessment criteria for a program's
      design, implementation, and user interface, create and evaluate a software
      tool that computes and visualizes the numbers in the Collatz sequence.

- **Creating**: Compile information together in a different way by
    combining elements in a new pattern or proposing alternative solutions.

    * **Keywords**: design, construct, improve, adapt, maximize, solve.
    * **Example**: After collecting information about the efficiency of
      different ways to uniqify a list, engineer a benchmarking framework that
      can run experiments to evaluate each approach. As the use of these
      benchmarks aids the identification of the best method, adapt each
      uniqifier so that it offers the best possible efficiency for a variety of
      inputs.

[^1]: See [Robert Talbert](https://rtalbert.org/)'s article [Re-thinking Bloom's
  Taxonomy for Flipped Learning
  Design](https://rtalbert.org/re-thinking-blooms-taxonomy-for-flipped-learning-design/)
  for a description of Bloom's taxonomy and how it aids the design of courses.
    In the context of programming, what level of the taxonomy is most exciting
    for you?

[^2]: Check out [Greg Wilson](https://third-bit.com/)'s book called [Teaching
  Tech Together](https://teachtogether.tech/) for lots of great ideas on how to
  teach programming to different types of learners. How could ideas from this
  book could be further applied to improve this learning platform?
